# Z-Render プロジェクト全体像

## 🎯 このプロジェクトは何？

**「GPUなしで3Dグラフィックスを描画するソフトウェアレンダラー」**

通常、3Dゲームやアプリは**GPU（グラフィックスカード）**を使います。しかし、このプロジェクトは**CPU（プロセッサ）だけ**で、ブラウザ上で3Dを描画します。

### なぜこんなことを？

- ✅ **学習目的**: GPUが裏でやっていることを完全に理解できる
- ✅ **最適化の極み**: メモリ、SIMD、並列化などの技術を学べる
- ✅ **ピュアな実装**: WebGLなどのAPIに頼らず、ゼロから作る

---

## 📚 3つのPhaseで何を実装したか

### Phase 1: 基礎 - 「画面にピクセルを表示する」

**目標**: WasmとJavaScriptを繋ぎ、ピクセルバッファに色を書き込んでブラウザに表示

#### 実装したもの

**1. フレームバッファ** (`framebuffer.zig`)

```
画面 = 横800 × 縦600 = 480,000ピクセル

各ピクセル = 1つの色（32bit = RGBA）

フレームバッファ = [色1, 色2, 色3, ..., 色480000]
```

- メモリ上に「画面全体のピクセル配列」を確保
- Wasmのリニアメモリに配置し、JavaScriptから直接読める

**2. SIMD数学ライブラリ** (`math/vec.zig`, `math/mat.zig`)

```
Vec3 = [x, y, z]     // 3D座標
Vec4 = [r, g, b, a]  // 色
Mat4 = 4×4行列        // 座標変換用
```

- Zigの`@Vector`型を使ってSIMD演算（複数の計算を同時に実行）
- 例: 4つの数値を一度に足し算できる

**3. Wasm ↔ JavaScript ブリッジ**

```
[Zig/Wasm]                [JavaScript]
ピクセルを計算 ------→ Canvas APIで表示
(framebuffer)          (putImageData)
```

**成果**: ボタンを押すと画面が赤・緑・青に塗りつぶされる

---

### Phase 2: 2D三角形 - 「色を塗る」

**目標**: 3つの頂点から三角形の内側を塗りつぶす（ラスタライズ）

#### 核心技術: 重心座標 (Barycentric Coordinates)

```
       v2 (青)
       /\
      /  \
     / p? \  ← この点pは三角形の中？外？
    /______\
  v0 (赤)  v1 (緑)
```

**重心座標の仕組み**:

- 点pを3頂点の「重み付き和」で表現
- `p = w0*v0 + w1*v1 + w2*v2` (w0+w1+w2=1)
- もし `w0, w1, w2` が全部 0〜1 なら、点pは三角形の**中**

**使い道**:

1. **内外判定**: 点が三角形の中にあるか？
2. **色の補間**: 頂点の色を混ぜる（Gouraud Shading）
   ```
   v0が赤、v1が緑、v2が青
   → 三角形の中央は3色が混ざって白っぽくなる
   ```

#### 実装したもの

**1. バウンディングボックス** - 無駄を省く

```
画面全体をチェック     三角形を囲む矩形だけチェック
800×600 = 48万回  →  100×100 = 1万回（48倍速い！）
```

**2. エッジ関数** - 内外判定

```
点pが辺の「左側」か「右側」か判定
3つの辺すべてで同じ側 → 三角形の中
```

**3. fillTriangle()** - 単色塗りつぶし

**4. fillTriangleInterpolated()** - 色を混ぜて塗る

**成果**: 画面中央に赤・緑・青のグラデーション三角形が表示される

---

### Phase 3: 3D空間 - 「奥行きを表現する」

**目標**: 回転する3Dキューブを正しく描画

#### 核心技術: 座標変換パイプライン

3Dオブジェクトを画面に表示するまでの**6つの変換**:

```
1. Local Space (ローカル空間)
   ↓ Model行列（回転・拡大・移動）

2. World Space (ワールド空間)
   ↓ View行列（カメラの位置と向き）

3. View Space (カメラ空間)
   ↓ Projection行列（遠近法）

4. Clip Space (クリップ空間)
   ↓ 透視除算（遠くを小さく）

5. NDC (正規化デバイス座標)
   ↓ ビューポート変換

6. Screen Space (画面座標)
```

#### 例: キューブの頂点1つを追跡

```
1. Local:  (-1, -1, -1)  ← キューブの左下前
   ↓ Model: Y軸で45度回転

2. World:  (-0.7, -1, -0.7)
   ↓ View: カメラは(0, 0, 5)から原点を見る

3. View:   (-0.7, -1, -5.7)
   ↓ Projection: 視野角60度

4. Clip:   (-0.4, -0.6, 3.8, 5.7)  ← w≠1の同次座標
   ↓ 透視除算: 各成分をwで割る

5. NDC:    (-0.07, -0.1, 0.67)  ← [-1,1]の立方体
   ↓ ビューポート: 画面800×600に変換

6. Screen: (372, 330, 0.84)  ← ピクセル座標(x,y) + 深度(z)
```

#### 実装したもの

**1. Mat4行列演算**

- `lookAt()`: カメラの位置と向きから View行列
- `perspective()`: 遠近法の Projection行列

**2. 深度バッファ (Z-Buffer)**

```
問題: 三角形を描く順番で結果が変わる

解決: 各ピクセルに「奥行き」を記憶

if (新しい三角形の奥行き < 既存の奥行き) {
  描画する（手前だから）
} else {
  スキップ（奥だから隠れる）
}
```

**3. バックフェイスカリング**

```
キューブの裏面は見えないから描かない
→ 描画する三角形が半分になる（2倍速い！）
```

**4. 3Dメッシュシステム**

```
キューブ = 8頂点 + 12三角形（6面×2）

頂点を共有してメモリ節約:
vertices = [v0, v1, v2, v3, v4, v5, v6, v7]
indices  = [(0,1,2), (0,2,3), ...]
```

**成果**: カラフルな3Dキューブがグルグル回る！

---

## 🔧 技術的なポイント

### 1. なぜZig？

- **高速**: C言語並みの速度
- **SIMD**: `@Vector`型で簡単に並列演算
- **メモリ安全**: でもヒープ割り当て不要
- **Wasm対応**: ビルドが簡単

### 2. なぜWasm（WebAssembly）？

- **高速**: JavaScriptより5〜10倍速い
- **ブラウザで動く**: インストール不要
- **メモリ共有**: JSとメモリを直接やり取り

### 3. パフォーマンスの工夫

**Phase 2で使った最適化:**

- ✓ バウンディングボックス → 計算量を48万回から1万回に削減
- ✓ ポインタ演算 → 関数呼び出しのオーバーヘッドなし
- ✓ SIMD → 色の計算を4成分同時処理

**Phase 3で追加した最適化:**

- ✓ バックフェイスカリング → 描画する三角形を半分に
- ✓ 深度バッファ → 正しい前後関係
- ✓ MVP行列の事前計算 → 毎フレーム1回だけ計算

---

## 📊 現在の状態

### ファイル構成

```
z-render/
├── src/
│   ├── math/           # 数学ライブラリ
│   │   ├── vec.zig    # ベクトル演算 (SIMD)
│   │   └── mat.zig    # 行列演算 (座標変換)
│   │
│   ├── render/         # レンダリングエンジン
│   │   ├── framebuffer.zig    # ピクセルバッファ
│   │   ├── depth_buffer.zig   # 深度バッファ
│   │   ├── rasterizer.zig     # 三角形の塗りつぶし
│   │   ├── mesh.zig           # 3Dメッシュデータ
│   │   ├── pipeline.zig       # 座標変換パイプライン
│   │   └── root.zig           # モジュールのエクスポート
│   │
│   └── main.zig        # Wasmエントリーポイント
│
├── web/
│   ├── index.html      # UI
│   └── renderer.js     # Wasm ↔ Canvas ブリッジ
│
└── build.zig           # ビルド設定
```

### コード規模

- **合計**: 約2,500行
- **コメント率**: 約40%（教育目的で詳しく解説）
- **テスト**: 20個以上

---

## 🎮 動作の流れ

### ブラウザで見える様子

```
1. ページを開く
   ↓
2. renderer.js が z-render.wasm を読み込む
   ↓
3. initFramebuffer(800, 600) を呼ぶ
   ↓
4. 毎フレーム (60FPS):
   │
   ├─ renderFrame() を呼ぶ (Wasm側)
   │  │
   │  ├─ フレームバッファをクリア
   │  ├─ 深度バッファをクリア
   │  ├─ 時間を進める（回転角度を計算）
   │  ├─ MVP行列を計算
   │  │
   │  └─ キューブの12三角形を描画:
   │     ├─ 頂点を変換 (Local → Screen)
   │     ├─ バックフェイスカリング
   │     ├─ ラスタライズ（重心座標）
   │     ├─ 深度テスト
   │     └─ 色を補間して描画
   │
   └─ blitToCanvas() で画面に転送 (JS側)
```

---

## 🚀 すごいところ

1. **完全に理解できる**
   - ブラックボックスなし
   - 1ピクセルがどう計算されるか追跡可能

2. **実践的な最適化技術**
   - キャッシュ効率
   - SIMD並列化
   - メモリレイアウト

3. **段階的な学習**
   - Phase 1: ピクセル
   - Phase 2: 2D三角形
   - Phase 3: 3D空間

4. **拡張性**
   - Phase 4でテクスチャマッピング
   - Phase 5でマルチスレッド化

---

## 🎯 次に学べること（Phase 4 & 5）

### Phase 4: リアルな見た目

- **テクスチャマッピング**: 画像を3Dオブジェクトに貼る
- **ライティング**: 光と影の計算
- **UV座標の補間**: 正しいテクスチャの貼り方

### Phase 5: 究極の最適化

- **SIMD化**: 4ピクセルを同時に処理
- **マルチスレッド**: Web Workersで並列化
- **タイルベースレンダリング**: 画面を分割して効率化

---

## 📖 関連ドキュメント

- [BARYCENTRIC_COORDINATES.md](./BARYCENTRIC_COORDINATES.md) - 重心座標の詳細解説
- [COORDINATE_TRANSFORM.md](./COORDINATE_TRANSFORM.md) - 座標変換パイプラインの詳細
- [DEPTH_BUFFER.md](./DEPTH_BUFFER.md) - 深度バッファの仕組み
