# 深度バッファ (Z-Buffer) 完全ガイド

## 🎯 深度バッファとは？

**各ピクセルに「奥行き情報」を記録**し、正しい前後関係で3Dオブジェクトを描画する技術。

```
問題: 三角形を描く順番で結果が変わる

三角形A (奥)    三角形B (手前)
      \         /
       \       /
        \     /
         \   /
          \ /

順序1: A→B  正しい（Bが手前に見える）
順序2: B→A  間違い（Aで上書きされる）
```

**深度バッファの解決策**:

```
各ピクセルに「最も手前の深度値」を記憶

新しい三角形を描くとき:
if (新しい深度 < 記録済み深度) {
    描画する（より手前だから）
    深度を更新
} else {
    スキップ（奥にあるから隠れる）
}
```

---

## 📊 データ構造

### フレームバッファと深度バッファ

```
フレームバッファ (Color Buffer)
+---+---+---+---+
| R | G | B | R | ← 各ピクセルの色 (u32)
+---+---+---+---+

深度バッファ (Depth Buffer / Z-Buffer)
+-----+-----+-----+-----+
| 0.5 | 0.8 | 0.3 | 0.9 | ← 各ピクセルの奥行き (f32)
+-----+-----+-----+-----+

同じサイズ: 800 × 600 = 480,000要素
```

### 深度値の範囲

```
NDC座標: Z ∈ [-1, 1]
↓ 正規化
深度バッファ: Z ∈ [0, 1]

0.0 = 最も手前 (ニアクリップ平面)
1.0 = 最も奥   (ファークリップ平面)
```

---

## 🔄 動作の流れ

### 1. 初期化

```zig
// すべてのピクセルを「無限遠」に設定
for (depth_buffer) |*depth| {
    depth.* = 1.0;  // 最大値
}
```

### 2. 三角形Aを描画

```
三角形A: 深度 = 0.7

ピクセル(100, 100):
  現在の深度: 1.0（初期値）
  新しい深度: 0.7
  → 0.7 < 1.0 なので描画
  → 深度バッファを 0.7 に更新
  → 色バッファを 赤 に更新
```

### 3. 三角形Bを描画

```
三角形B: 深度 = 0.5（より手前）

ピクセル(100, 100):
  現在の深度: 0.7
  新しい深度: 0.5
  → 0.5 < 0.7 なので描画
  → 深度バッファを 0.5 に更新
  → 色バッファを 青 に更新
```

### 4. 三角形Cを描画

```
三角形C: 深度 = 0.8（より奥）

ピクセル(100, 100):
  現在の深度: 0.5
  新しい深度: 0.8
  → 0.8 > 0.5 なのでスキップ
  → 何も更新しない（青のまま）
```

---

## 💡 実装例

### 深度バッファの定義

```zig
const MAX_PIXELS = 1920 * 1080;
var buffer: [MAX_PIXELS]f32 = undefined;
var width: u32 = 0;
var height: u32 = 0;
```

### 初期化とクリア

```zig
pub fn init(w: u32, h: u32) bool {
    width = w;
    height = h;
    clear();
    return true;
}

pub fn clear() void {
    const size = width * height;
    for (buffer[0..size]) |*depth| {
        depth.* = 1.0;  // 無限遠
    }
}
```

### 深度テスト

```zig
pub fn testAndSet(x: u32, y: u32, depth: f32) bool {
    if (x >= width or y >= height) return false;

    const index = y * width + x;
    const current_depth = buffer[index];

    // 新しい深度が手前にある？
    if (depth < current_depth) {
        buffer[index] = depth;  // 更新
        return true;            // 描画OK
    }

    return false;  // 描画NG（奥にある）
}
```

### ラスタライザでの使用

```zig
pub fn fillTriangle3D(v0: Vertex, v1: Vertex, v2: Vertex) void {
    // ... バウンディングボックス計算 ...

    for (y = min_y..max_y) {
        for (x = min_x..max_x) {
            const bc = barycentric(v0.pos, v1.pos, v2.pos, p);

            if (bc.x >= 0 and bc.y >= 0 and bc.z >= 0) {
                // 深度値を補間
                const depth = bc.x * v0.depth +
                              bc.y * v1.depth +
                              bc.z * v2.depth;

                // 深度テスト
                if (depth_buffer.testAndSet(x, y, depth)) {
                    // 色を補間して描画
                    const color = interpolateColor(v0, v1, v2, bc);
                    framebuffer.setPixel(x, y, color);
                }
            }
        }
    }
}
```

---

## 🎨 視覚的な例

### 2つの三角形が重なる場合

```
横から見た図:

カメラ          三角形B      三角形A
  👁️  ←------ (手前) ←----- (奥)
                z=0.3        z=0.7

上から見た図:

  ┌─────────────┐
  │      B      │
  │    ┌───┐    │
  │    │ A │    │
  │    └───┘    │
  └─────────────┘

重なり部分での深度:
  B: 0.3
  A: 0.7
  → Bが勝つ（手前だから）
```

### 深度バッファの状態変化

```
初期状態:
Color:  [□ □ □ □ □]
Depth:  [1 1 1 1 1]

三角形A (z=0.7, 赤) を描画:
Color:  [□ R R R □]
Depth:  [1 .7.7.7 1]

三角形B (z=0.3, 青) を描画:
Color:  [B B R B B]  ← 中央はAが勝つ（0.7 > 0.3なのでBがスキップ）
Depth:  [.3.3.7.3.3]

三角形C (z=0.5, 緑) を描画:
Color:  [B B R B B]  ← 変化なし（すべて既存より奥）
Depth:  [.3.3.7.3.3]  ← 変化なし
```

---

## ⚡ 最適化技術

### 1. Early-Z (Early Depth Test)

ピクセルシェーダーの**前**に深度テストを行う。

```zig
// 通常の順序
1. 色を計算（重い処理）
2. 深度テスト
3. テストに失敗 → 色の計算が無駄

// Early-Zの順序
1. 深度テスト
2. テストに失敗 → 色の計算をスキップ
3. テストに成功 → 色を計算
```

このプロジェクトでは既にEarly-Z相当を実装済み。

### 2. Hierarchical Z-Buffer (HZB)

画面を**階層的なタイル**に分割し、タイル単位で深度テスト。

```
レベル0 (4x4ピクセル):
各ピクセルの深度

レベル1 (2x2タイル):
各タイルの最小深度

レベル2 (1x1):
全体の最小深度

大きな三角形を描くとき:
→ まずレベル2でテスト
→ 完全に隠れているならスキップ（4x4全部スキップ！）
```

Phase 5で実装予定。

### 3. Reverse-Z

深度値を**逆順**にする（1.0 = 近、0.0 = 遠）。

**なぜ？**

浮動小数点の精度は0に近いほど高い。

```
通常のZ:
  near (0.0)  |--細かい--|  far (1.0)
              ↑           ↑
            高精度      低精度

Reverse-Z:
  far (0.0)  |--細かい--|  near (1.0)
              ↑           ↑
  遠方の精度向上      近傍は元々精度十分
```

Phase 5で実装予定。

---

## 🚨 よくある問題

### 1. Z-Fighting

同じ深度の2つの面が「ちらつく」現象。

```
原因: 浮動小数点の精度不足

壁A: z = 0.500000
壁B: z = 0.500001  ← ほぼ同じ

ピクセルごとに誤差で勝者が変わる
→ ちらつく
```

**解決策**:

- ポリゴンオフセット（少しずらす）
- Reverse-Z（精度向上）
- より大きなnear/far比を避ける

### 2. 深度精度の偏り

透視投影では**遠方の精度が低い**。

```
深度値の分布（通常の透視投影）:

near (0.1)                far (100.0)
  |###########................|
   ↑細かい        ↑粗い
 近傍は高精度    遠方は低精度

理由: 透視投影の非線形性
```

**解決策**:

- near/farの比を小さくする（near=0.1, far=100 より near=1, far=1000の方が良い）
- Reverse-Z
- 対数深度バッファ

### 3. メモリ使用量

```
1920 × 1080 × 4 bytes (f32) = 8,294,400 bytes ≈ 8MB

色バッファと合わせて約16MB

→ L1/L2キャッシュに収まらない
→ メモリアクセスがボトルネック
```

**解決策**:

- タイルベースレンダリング（小さな領域ずつ処理）
- 深度バッファの圧縮

---

## 📐 深度値の補間

### 重心座標で補間

```zig
// 3頂点の深度
v0.z = 0.3
v1.z = 0.5
v2.z = 0.8

// ピクセルpの重心座標
bc = (0.2, 0.5, 0.3)

// 深度を補間
depth = 0.2 * 0.3 + 0.5 * 0.5 + 0.3 * 0.8
      = 0.06 + 0.25 + 0.24
      = 0.55
```

### パースペクティブコレクト補間

**問題**: 単純な線形補間は透視投影で正しくない。

```
透視投影では「遠くほど圧縮される」ため、
スクリーン座標での線形補間 ≠ 3D空間での線形補間
```

**解決**: w座標で補正

```zig
// 正しい補間（Phase 4で実装予定）
depth = (bc.x * v0.z / v0.w +
         bc.y * v1.z / v1.w +
         bc.z * v2.z / v2.w) /
        (bc.x / v0.w + bc.y / v1.w + bc.z / v2.w)
```

現在のPhase 3では簡易版（線形補間）を使用。

---

## 🔬 アルゴリズムの歴史

### 1974年: Z-Bufferの発明

Ed Catmull が博士論文で提案。

**それまで**:

- Painter's Algorithm（奥から順に描画）
- 三角形のソートが必要（O(n log n)）
- 循環依存がある場合は破綻

**Z-Bufferの利点**:

- ソート不要
- O(n) の計算量
- どんな順序でも正しく描画

### 1980年代: ハードウェア実装

GPUに深度バッファが組み込まれる。

### 2000年代: Early-Z, HZB

さらなる高速化技術が実装される。

---

## 📖 参考資料

- [Learn OpenGL: Depth testing](https://learnopengl.com/Advanced-OpenGL/Depth-testing)
- [Wikipedia: Z-buffering](https://en.wikipedia.org/wiki/Z-buffering)
- [Reverse-Z 技術解説](https://developer.nvidia.com/content/depth-precision-visualized)
