//! Mesh (3Dメッシュデータ)
//! ========================
//!
//! 3Dモデルの頂点データとインデックスデータを管理します。
//!
//! ## 学習ポイント
//!
//! ### 1. 頂点データ (Vertex Data)
//!
//! 各頂点は以下の情報を持ちます：
//! - 位置（pos）: ローカル座標系での3D位置
//! - 色（color）: 頂点カラー（Phase 2のGouraud Shadingで使用）
//! - TODO Phase 4: UV座標、法線ベクトル
//!
//! ### 2. インデックスバッファ (Index Buffer)
//!
//! 頂点を再利用するため、三角形は頂点のインデックスで表現します。
//!
//! ```
//! 頂点配列:
//!   [v0, v1, v2, v3, v4, v5, v6, v7]  // 8頂点のキューブ
//!
//! インデックス配列（三角形）:
//!   [(0,1,2), (0,2,3), ...]  // 12三角形（6面×2三角形）
//! ```
//!
//! メモリ効率: 頂点を共有することでメモリ使用量を削減
//!
//! ### 3. メッシュの構造
//!
//! - **Vertex3D**: 頂点の属性（位置、色など）
//! - **Triangle**: 3つの頂点インデックス
//! - **Mesh**: 頂点配列とインデックス配列のペア
//!
//! ## TODO (Phase 4)
//!
//! - UV座標の追加（テクスチャマッピング）
//! - 法線ベクトルの追加（ライティング）
//! - タンジェント空間（ノーマルマッピング）

const std = @import("std");
const math = @import("../math/root.zig");
const Vec3 = math.Vec3;
const Vec4 = math.Vec4;
const vec3 = math.vec.vec3;
const vec4 = math.vec.vec4;

// =============================================================================
// データ構造
// =============================================================================

/// 3D頂点（位置 + 色）
///
/// ## 学習ポイント
///
/// Phase 3では色のみですが、Phase 4でUV座標と法線を追加します。
/// 構造体のメモリレイアウトを意識することで、キャッシュ効率が向上します。
pub const Vertex3D = struct {
    pos: Vec3, // ローカル座標（モデル空間）
    color: Vec4, // RGBA色（各成分 0.0〜1.0）

    /// 頂点を生成
    pub fn init(x: f32, y: f32, z: f32, r: f32, g: f32, b: f32, a: f32) Vertex3D {
        return .{
            .pos = vec3.init(x, y, z),
            .color = vec4.init(r, g, b, a),
        };
    }
};

/// 三角形（頂点インデックスの3つ組）
///
/// ## 学習ポイント
///
/// - 頂点の巻き順は反時計回り（CCW: Counter-Clockwise）を推奨
/// - これにより、外積で計算した法線が表面の外側を向く
/// - バックフェイスカリングに使用
pub const Triangle = struct {
    v0: u32, // 頂点0のインデックス
    v1: u32, // 頂点1のインデックス
    v2: u32, // 頂点2のインデックス
};

/// メッシュ（頂点配列 + インデックス配列）
///
/// ## 学習ポイント
///
/// - `[]const` スライスは「読み取り専用の配列ビュー」
/// - メッシュデータは静的に確保されることを想定（ヒープ割り当てなし）
/// - 将来的にはOBJファイルローダーを実装予定
pub const Mesh = struct {
    vertices: []const Vertex3D,
    indices: []const Triangle,

    /// 三角形の数を取得
    pub fn triangleCount(self: Mesh) usize {
        return self.indices.len;
    }

    /// 頂点の数を取得
    pub fn vertexCount(self: Mesh) usize {
        return self.vertices.len;
    }
};

// =============================================================================
// プリミティブメッシュ生成
// =============================================================================

/// キューブメッシュを生成（静的データ）
///
/// ## 構造
///
/// ```
///      7 -------- 6
///     /|         /|
///    / |        / |
///   3 -------- 2  |
///   |  |       |  |
///   |  4 ------|--5
///   | /        | /
///   |/         |/
///   0 -------- 1
/// ```
///
/// 頂点番号:
/// - 0: (-1, -1, -1) 左下前
/// - 1: ( 1, -1, -1) 右下前
/// - 2: ( 1,  1, -1) 右上前
/// - 3: (-1,  1, -1) 左上前
/// - 4: (-1, -1,  1) 左下後
/// - 5: ( 1, -1,  1) 右下後
/// - 6: ( 1,  1,  1) 右上後
/// - 7: (-1,  1,  1) 左上後
///
/// ## 学習ポイント
///
/// - 各面は2つの三角形で構成（合計12三角形）
/// - 頂点の巻き順は反時計回り（表面を向く）
/// - 各頂点に異なる色を割り当て（Gouraud Shading用）
pub const CUBE_VERTICES = [8]Vertex3D{
    // Z- 面（前面）
    Vertex3D.init(-1, -1, -1, 1.0, 0.0, 0.0, 1.0), // 0: 赤
    Vertex3D.init(1, -1, -1, 0.0, 1.0, 0.0, 1.0), // 1: 緑
    Vertex3D.init(1, 1, -1, 0.0, 0.0, 1.0, 1.0), // 2: 青
    Vertex3D.init(-1, 1, -1, 1.0, 1.0, 0.0, 1.0), // 3: 黄

    // Z+ 面（背面）
    Vertex3D.init(-1, -1, 1, 1.0, 0.0, 1.0, 1.0), // 4: マゼンタ
    Vertex3D.init(1, -1, 1, 0.0, 1.0, 1.0, 1.0), // 5: シアン
    Vertex3D.init(1, 1, 1, 1.0, 1.0, 1.0, 1.0), // 6: 白
    Vertex3D.init(-1, 1, 1, 0.5, 0.5, 0.5, 1.0), // 7: 灰
};

pub const CUBE_INDICES = [12]Triangle{
    // Z- 面（前面）
    .{ .v0 = 0, .v1 = 1, .v2 = 2 },
    .{ .v0 = 0, .v1 = 2, .v2 = 3 },

    // Z+ 面（背面）
    .{ .v0 = 5, .v1 = 4, .v2 = 7 },
    .{ .v0 = 5, .v1 = 7, .v2 = 6 },

    // Y+ 面（上面）
    .{ .v0 = 3, .v1 = 2, .v2 = 6 },
    .{ .v0 = 3, .v1 = 6, .v2 = 7 },

    // Y- 面（下面）
    .{ .v0 = 4, .v1 = 5, .v2 = 1 },
    .{ .v0 = 4, .v1 = 1, .v2 = 0 },

    // X+ 面（右面）
    .{ .v0 = 1, .v1 = 5, .v2 = 6 },
    .{ .v0 = 1, .v1 = 6, .v2 = 2 },

    // X- 面（左面）
    .{ .v0 = 4, .v1 = 0, .v2 = 3 },
    .{ .v0 = 4, .v1 = 3, .v2 = 7 },
};

/// キューブメッシュを取得
pub fn getCubeMesh() Mesh {
    return .{
        .vertices = &CUBE_VERTICES,
        .indices = &CUBE_INDICES,
    };
}

// =============================================================================
// テスト
// =============================================================================

test "cube mesh" {
    const cube = getCubeMesh();
    try std.testing.expectEqual(@as(usize, 8), cube.vertexCount());
    try std.testing.expectEqual(@as(usize, 12), cube.triangleCount());
}

test "vertex creation" {
    const v = Vertex3D.init(1.0, 2.0, 3.0, 0.5, 0.5, 0.5, 1.0);
    try std.testing.expectEqual(@as(f32, 1.0), v.pos[0]);
    try std.testing.expectEqual(@as(f32, 2.0), v.pos[1]);
    try std.testing.expectEqual(@as(f32, 3.0), v.pos[2]);
    try std.testing.expectEqual(@as(f32, 0.5), v.color[0]);
}
